#! /bin/bash
# runx: Provide an X server in WSL

Version="0.1.4"

usage() {                       # Usage information (--help)
  echo "runx - Provide an X server on MS Windows in WSL, MSYS2 or Cygwin
Run Linux GUI applications on MS Windows.

Syntax:
  runx [OPTIONS]  --  [COMMAND]

Options:
  -h, --help                     Show this help.
  -d, --desktop                  Open a parent window for desktop environments.
  -g, --gpu [=yes|no]            Enable GPU hardware acceleration. Default: no.
                                 Can fail with NVIDIA cards. Works better with
                                 XWin in Cygwin than with VcXsrv.
  -c, --clipboard [=yes|no]      Enable clipboard sharing yes/no. Default: yes.
      --display N                Display number N for new X server.
      --no-auth                  Disable X cookie authentication. Discouraged.
      --cleanup                  Stop all X servers and delete cookies.
  -v, --verbose                  Be verbose.

Installation in WSL, MSYS2 or Cygwin:
 - Copy runx into /usr/local/bin/
 - Make runx executeable:        sudo chmod +x /usr/local/bin/runx
 - Install xauth and xwininfo:   sudo apt install xauth x11-utils
Install on Windows:
 - Download and install X server VcXsrv from: 
     https://sourceforge.net/projects/vcxsrv/
(In Cygwin you can install XWin (package xinit) instead of VcXsrv.)

Usage:
You can create an entry in ~/.bashrc to always have an X server available.
Possible entry in ~/.bashrc:     source /usr/local/bin/runx

Example to directly run an application with runx:
 - Install file manager pcmanfm: sudo apt update
                                 sudo apt install pcmanfm
 - Run pcmanfm with:             runx -- pcmanfm

Example to run Mate desktop:
 - Install Mate desktop with:    sudo apt install mate-desktop-environment
 - Run Mate desktop with:        runx --desktop -- mate-session

runx version $Version" >&2
}

finish() {                      # Clean up and terminate
  [ "$RUNX_XPID" ] && ps -p "$RUNX_XPID" >/dev/null 2>&1 && {
    verbose "Terminating X server $RUNX_XPID"
    kill "$RUNX_XPID"
  }
  case "$Sourced" in
    yes)
      unset -f finish error warning note verbose rmcr escapestring check_host check_displaynumber generate_xcommand setup_cookie convertpath getwslpath declare_variables parse_options check_dependencies main
      Exitcode="${1:-0}"
    ;;
    no)
      exit "${1:-0}"
    ;;
  esac
}

error() {                       # Show error message and exit
  echo -e "${Colredbg}runx ERROR:${Colnorm} $*
" >&2
  Exitcode=1
}

warning() {                     # Show warning messages
  echo "${Colyellow}runx WARNING:${Colnorm} $*
" >&2
}

note() {                        # Show notice messages
  echo "${Colgreen}runx note:${Colnorm} $*
" >&2
}

verbose() {                     # Show verbose message (--verbose)
  [ "$Verbose" = "yes" ] && note "$*"
}

rmcr() {                        # Remove carriage return to translate DOS/Windows newlines into UNIX newlines.
  # Convert stdin if $1 is empty. Otherwise convert file $1.
  case "${1:-}" in
    "") sed    "s/$(printf "\r")//g" ;;
    *)  sed -i "s/$(printf "\r")//g"  "${1:-}"
  esac
}

escapestring() {                # Escape special chars of $1
  # escape all characters except those described in [^a-zA-Z0-9,._+@=:/-]
  echo "${1:-}" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@=:/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}

convertpath() {                 # Convert unix and windows pathes
  # $1: Mode:
  #   --windows   echo windows path                - result: C:/path
  #   --unix      echo unix path                   - result: /c/path
  #   --subsystem echo path within subsystem       - result: /cygdrive/c/path  or  /path
  #   --volume    echo --volume compatible syntax  - result: 'unixpath':'containerpath':rw  (or ":ro")
  #   --container echo path of volume in container - result: /path
  # $2: Path to convert. Arbitrary syntax, can be C:/path, /c/path, /cygdrive/c/path, /path
  #     Can have suffix :rw or :ro. If none is given, return with :rw
  # $3: Optional for --volume: containerpath
  
  local Mode= Path= Drive= Readwritemode=
  
  Mode="${1:-}"
  Path="${2:-}"

  # check path for suffix :rw or :ro
  Readwritemode="$(echo "$Path" | rev | cut -c1-3 | rev)"
  [ "$(cut -c1 <<< "$Readwritemode")" = ":" ] && {
    Path="$(echo "$Path" | rev | cut -c4- | rev)"
  } || Readwritemode=":rw"

  # replace ~ with HOME
  Path="$(sed s%"~"%"${Hostuserhome:-${HOME:-}}"% <<< "$Path")"
  
  # not on Windows
  [ -z "$Winsubsystem" ] && {
    case $Mode in
      --unix|--subsystem) echo "$Path" ;;
      --windows) warning "Nonsense path conversion $Mode: $Path" ; return 1 ;;
      --volume) echo "'$Path':'${3:-$Path}'$Readwritemode" ;;
      --container) echo "${3:-$Path}" ;;
    esac
    return 0
  }
  
  # replace \ with /
  Path="$(tr '\\' '/' <<< "$Path")"
  
  # remove possible already given mountpoint
  Path="${Path#$Winsubmount}"
  
  # Given format is /c/
  [ "$(cut -c1,3 <<< "$Path")" = "//" ] && {
    Drive="$(cut -c2 <<< "$Path")"
    Path="$(cut -c3- <<< "$Path")"
  }
  
  # Given format is C:/
  [ "$(cut -c2 <<< "$Path")" = ":" ] && {
    Drive="$(cut -c1 <<< "$Path")"
    Path="$(cut -c3- <<< "$Path")"
  }
  
  # change C to c
  Drive="${Drive,}"

  [ "$Winsubsystem" = "WSL" ] && [ -z "$Drive" ] && case $Mode in
    --windows|--unix|--volume)
      warning "Request of Windows path to path within WSL:
  $Path
  Write access from Windows host to WSL files can damage WSL.
  Read-only access is ok."
    ;;
  esac

  case $Drive in
    "") # Path points into subsystem
      Path="${Path#"$Winsubpath"}"
      Drive="$(cut -c2 <<<"$Winsubpath")"
      case $Mode in
        --windows)   echo "${Drive^}:$(cut -c3- <<<$Winsubpath)$Path" ;;
        --unix)      echo "$Winsubpath$Path" ;;
        --subsystem) echo "$Path" ;;
        --volume)    echo "'$Winsubpath$Path':'${3:-$Path}'$Readwritemode" ;;
        --container) echo "${3:-$Path}" ;;
      esac
    ;;
    *) # Path outside of subsystem
      case $Mode in
        --windows)   echo "${Drive^}:$Path" ;;
        --unix)      echo "/$Drive$Path" ;;
        --subsystem) echo "$Winsubmount/$Drive$Path" ;;
        --volume)    echo "'/$Drive$Path':'${3:-/$Drive$Path}'$Readwritemode" ;;
        --container) echo "${3:-/$Drive$Path}" ;;
      esac
    ;;
  esac
  return 0
}

check_host() {

  # Check for MS Windows subsystem
  uname -r | grep -q Microsoft                    && Winsubsystem="WSL"
  command -v cygcheck.exe >/dev/null && {
    cygcheck.exe -V | rmcr | grep -q "(cygwin)"   && Winsubsystem="CYGWIN"
    cygcheck.exe -V | rmcr | grep -q "(msys)"     && Winsubsystem="MSYS2"
  }
  
  [ "$0" = "$BASH_SOURCE" ] && Sourced="no" || Sourced="yes"
  verbose "Script is being sourced yes/no: $Sourced"
  
  case $Winsubsystem in
    MSYS2|CYGWIN) 
      Winsubmount="$(cygpath.exe -u "c:/" | rmcr | sed s%/c/%%)"
      Winsubpath="$(convertpath --unix "$(cygpath.exe -w "/" | rmcr)" )" ;;
    WSL)          
      Winsubmount="/mnt"
      grep -q "Windows" <<< "${PATH:-}" || export PATH="${PATH:-}:$Winsubmount/c/Windows/System32:$Winsubmount/c/Windows/System32/WindowsPowerShell/v1.0" # can miss after sudo
      Winsubpath="$(convertpath --unix "$(getwslpath)")" ;;
  esac
  
  # Check IP of Windows host
  Hostip="$(ipconfig.exe | rmcr | grep -A6 'DockerNAT' | grep 'IPv4' | rev | cut -d' ' -f1 | rev)"
  [ "$Hostip" ] || Hostip="$(ipconfig.exe | rmcr | grep 'IPv4' | grep -o '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*' | grep "^10\.0\.*" )"
  [ "$Hostip" ] || Hostip="$(ipconfig.exe | rmcr | grep 'IPv4' | head -n1 | | rev | cut -d' ' -f1 | rev)"
  verbose "Host IP adress: $Hostip"
  
  return 0
}

check_displaynumber() {         # Find free display number, print on stdout
  verbose "Searching for free display number."
  for ((Newdisplaynumber=100 ; Newdisplaynumber <=1000 ; Newdisplaynumber++)); do
    grep -q -E 'Authorization|Absolute|MIT-MAGIC-COOKIE' <<< "$(xwininfo -display $Hostip:$Newdisplaynumber -root 2>&1)" || break
  done
}

generate_xcommand() {           # Generate command to start X server VcXsrv
  

  Xcommand="$(escapestring "$Xserverexe") :$Newdisplaynumber -listen tcp -retro -lesspointer"
  
  # GPU hardware acceleration
  case $Sharegpu in
    yes) Xcommand="$Xcommand -wgl   +iglx" ; export LIBGL_ALWAYS_INDIRECT=1 ;;
    no)  Xcommand="$Xcommand -nowgl -iglx" ; unset  LIBGL_ALWAYS_INDIRECT   ;;
  esac
  
  # Seamless or desktop mode
  [ "$Desktopmode" = "no" ] && Xcommand="$Xcommand -multiwindow"
      
  # Clipboard
  case $Shareclipboard in
    yes) Xcommand="$Xcommand -clipboard" ;;
    no)  Xcommand="$Xcommand -noclipboard" ;;
  esac

  case $Xauthentication in
    yes) 
      case "$Xserverexe" in
        "$Xwinexe")   Xcommand="$Xcommand -auth '$Xservercookie'" ;;
        "$Vcxsrvexe") Xcommand="$Xcommand -auth '$(convertpath --windows "$Xservercookie")'" ;;
      esac
    ;;
    no)  Xcommand="$Xcommand -ac" ;;
  esac
  
  # X server extensions
  Xcommand="$Xcommand \
  +extension RANDR \
  +extension RENDER \
  +extension GLX \
  +extension DOUBLE-BUFFER \
  +extension SECURITY \
  +extension DAMAGE \
  +extension COMPOSITE \
  -extension X-Resource \
  -extension XTEST"
  
  verbose "Generated X command:
  $Xcommand"
}

setup_cookie() {             # Generate X authentication cookie
  local Cookie
  
  Xclientcookie="$(convertpath --subsystem "~/runx_Xauthority")"
  Xservercookie="$(convertpath --subsystem "$(cmd.exe /C "echo %userprofile%")" | rmcr)/runx_Xauthority"
  
  verbose "Cookies:
  $Xservercookie
  $Xclientcookie"

  # remove old cookies if no VcXsrv is running yet
  command -v tasklist.exe >/dev/null && {
    tasklist.exe | rmcr | grep -q -E 'vcxsrv.exe|XWin.exe' || {
      verbose "Removing old cookies."
      [ -e "$Xservercookie" ] && rm "$Xservercookie"
      [ -e "$Xclientcookie" ] && rm "$Xclientcookie"
    }
  }
  
  touch "$Xclientcookie"
  touch "$Xservercookie"
  
  # generate fresh cookie
  xauth -i -f "$Xclientcookie" add :$Newdisplaynumber . $(mcookie)
  # prepare cookie with localhost identification disabled by ffff. ffff means 'familiy wild'
  Cookie="$(xauth -i -f "$Xclientcookie" nlist | sed -e 's/^..../ffff/')"
  echo "$Cookie" | xauth -i -f "$Xclientcookie" nmerge -
  echo "$Cookie" | xauth -i -f "$Xservercookie" nmerge -
  
  verbose "Client cookie:
$(xauth -v -f "$Xclientcookie" list)"
  verbose "Server cookie:
$(xauth -v -f "$Xservercookie" list)"
}

getwslpath() {                  # get path to currently running WSL system

  # Fork from https://github.com/Microsoft/WSL/issues/2578#issuecomment-354010141
  
  local RUN_ID= BASE_PATH=
  
  RUN_ID="/tmp/$(mcookie)"

  # Mark our filesystem with a temporary file having an unique name.
  touch "${RUN_ID}"

  powershell.exe -Command '(Get-ChildItem HKCU:\Software\Microsoft\Windows\CurrentVersion\Lxss | ForEach-Object {Get-ItemProperty $_.PSPath}).BasePath.replace(":", "").replace("\", "/")' | while IFS= read -r BASEPATH; do
    # Remove trailing whitespaces.
    BASEPATH="${BASEPATH%"${BASEPATH##*[![:space:]]}"}"
    # Build the path on WSL.
    BASEPATH="/mnt/${BASEPATH,}/rootfs"

    # Current WSL instance doesn't have an access to its mount from within
    # itself despite all others are available. That's the hacky way we're
    # using to determine current instance.
    #
    # The second of part of the condition is a fallback for a case if our
    # trick will stop working. For that we've created a temporary file with
    # an unique name and now seeking it among all WLSs.
    if ! ls "${BASEPATH}" > /dev/null 2>&1 || [ -f "${BASEPATH}${RUN_ID}" ]; then
      echo "${BASEPATH}"
      # You can create and simultaneously run multiple WSL instances, comment
      # out the "break", run this script within each one and it'll return only
      # single value.
      break
    fi
  done
  rm "${RUN_ID}"
  return 0
}

cleanup() {
  # kill all instances of VcXsrv and remove cookies
  MSYS2_ARG_CONV_EXCL='*' tasklist.exe | rmcr | grep -E 'vcxsrv.exe|XWin.exe'
  MSYS2_ARG_CONV_EXCL='*' taskkill.exe /F /PID vcxsrv.exe
  MSYS2_ARG_CONV_EXCL='*' taskkill.exe /F /PID xwin.exe
  # Remove cookies
  Newdisplaynumber=0
  setup_cookie
  rm -v "$Xclientcookie" "$Xservercookie"
}

declare_variables() {
  # Default values
  Desktopmode="no"
  Screensize="" ###
  Shareclipboard="no" ###
  Sharegpu="no"
  Verbose="no"
  Xauthentication="yes"
  
  # Terminal colors used for messages and --verbose=c
  Esc="$(printf '\033')"
  Colblue="${Esc}[35m"
  Colyellow="${Esc}[33m"
  Colgreen="${Esc}[32m"
  Colgreenbg="${Esc}[42m"
  Colred="${Esc}[31m"
  Colredbg="${Esc}[41m"
  Coluline="${Esc}[4m"
  Colnorm="${Esc}[0m"
  
  # Empty global vars needed later
  Exitcode=""
  Hostip=""
  Newdisplaynumber=""
  Sourced=""
  Vcxsrvexe=""
  Winsubmount=""
  Winsubpath=""
  Xcommand=""
  Xserverexe=""
  Xwinexe=""
}

parse_options() {
  
  local Shortoptions Longoptions Parsererror
  Shortoptions="cdghv"
  Longoptions="desktop,gpu::,clipboard::,display:,no-auth,help,verbose,version,cleanup"
  
  Parsedoptions="$(getopt --options $Shortoptions --longoptions $Longoptions --name "$0" -- "$@" 2>/tmp/runx_parsererror)"
  [ -e /tmp/runx_parsererror ] && Parsererror=$(cat /tmp/runx_parsererror) && rm /tmp/runx_parsererror
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  verbose "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
         --version)   echo "runx version $Version"; Exitcode=0 ;;
         --no-auth)   Xauthentication="no" ;;
         --cleanup)   Cleanup="yes" ;;
      -c|--clipboard) Clipboard="${2:-yes}"; shift ;;
      -d|--desktop)   Desktopmode="yes" ;;
         --display)   Newdisplaynumber="${2:-}" ; shift ;;
      -g|--gpu)       Sharegpu="${2:-yes}" ;;
      -h|--help)      usage; finish ;;
      -v|--verbose)   Verbose="yes" ;;
      --) shift;      Hostcommand="$@"; break ;;
      *) error "Unknown option: ${1:-}
  $(usage 2>&1)"
    esac
    shift
  done
}

check_dependency() {
  command -v "${1:-}" >/dev/null || {
    note "Command not found: ${1:-}"
    return 1
  }
  return 0
}

check_dependencies() {
  local Line
  
  case "$Winsubsystem" in
    WSL|CYGWIN|MSYS2) ;;
    *) error "runx is designed to run on MS Windows in WSL, Cygwin or MSYS2.
  Did not detect WSL, Cygwin or MSYS2." ;; ###
  esac
  
  [ "$Xauthentication" = "yes" ] && {
    check_dependency xauth || error "Missing dependency: xauth
  Cannot create an authorization cookie for X server access.
  Please install package in $Winsubsystem:  xauth
  You can disable cookie authentication with discouraged option --no-auth."
  }
  [ "$Newdisplaynumber" ] || {
    check_dependency xwininfo || {
      Newdisplaynumber="$((RANDOM / 10))"
      warning "Missing dependency: xwininfo
  Cannot check for a free display number.
  Please install package in $Winsubsystem:  xwininfo  or  x11-utils
  Fallback: Using random display number :$Newdisplaynumber .
  If this display number is already in use, the startup will fail.
  You can specify a custom display number with option --display=N."
    }
  }
  # mcookie ### FIXME
  
  Vcxsrvexe="$(command -v vcxsrv.exe)"
  [ "$Vcxsrvexe" ] || Vcxsrvexe="$(command -v "$(convertpath --subsystem "C:/Program Files/VcXsrv/vcxsrv.exe")")"
  Xwinexe="$(command -v XWin)"
  verbose "Found X servers:
  $Vcxsrvexe
  $Xwinexe"
  Xserverexe="${Xwinexe:-$Vcxsrvexe}"

  for Line in cmd.exe ipconfig.exe powershell.exe tasklist.exe taskkill.exe; do
    check_dependency "$Line" || error "Did not find Windows command: $Line"
  done
  
  check_dependency "${Xserverexe:-vcxsrv.exe}" || {
    case $Winsubsystem in
      CYGWIN) error "No X server found. 
  Please install VcXsrv on Windows: https://sourceforge.net/projects/vcxsrv
  or install Cygwin packages xinit, xauth and xwininfo." ;;
      *) error "X server VcXsrv not found. Please install VcXsrv on Windows from: 
  https://sourceforge.net/projects/vcxsrv/" ;;
    esac
  }
}

main() {
  [ "$Newdisplaynumber" ] || check_displaynumber
  [ "$Xauthentication" = "yes" ] && setup_cookie
  generate_xcommand

  export DISPLAY=$Hostip:$Newdisplaynumber
  case "$Xauthentication" in
    yes)
      export XAUTHORITY="$Xclientcookie"
      verbose "DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY"
      echo "DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY"
    ;;
    no)
      unset XAUTHORITY
      verbose "DISPLAY=$DISPLAY"
      echo "DISPLAY=$DISPLAY"
    ;;
  esac
  
  [ "$Verbose" = "yes" ] && Xcommand="$Xcommand 1>&2" || Xcommand="$Xcommand >/dev/null 2>&1"
  { [ "$Hostcommand" ] || [ "$Sourced" = "yes" ] ; }  && Xcommand="$Xcommand & RUNX_XPID=\$!"
  
  note "Windows firewall settings can forbid application access
  to the X server. If no application window appears, but no obvious error
  is shown, please check your firewall settings. 
  Compare:  https://github.com/mviereck/x11docker/issues/108
  Just in case of broken cookies also run:  runx --cleanup"
  
  eval $Xcommand
  
  [ "$RUNX_XPID" ] && {
    export RUNX_XPID
    verbose "PID of X server: $RUNX_XPID
  $(ps -p "$RUNX_XPID")"
  } || unset RUNX_XPID
   
  [ "$Sourced" = "yes" ]     && export RUNX_SOURCED=1 || unset RUNX_SOURCED
  [ "$Desktopmode" = "yes" ] && export RUNX_DESKTOP=1 || unset RUNX_DESKTOP
  
  [ "$Hostcommand" ] && {
    verbose "Executing command:
  $Hostcommand"
    eval $Hostcommand
  }
}

declare_variables
parse_options "$@"
check_host
check_dependencies
[ "$Cleanup" = "yes" ] && cleanup && Exitcode="${Exitcode:-0}"
[ "$Exitcode" ] || main
finish "${Exitcode:-0}"

todo() {
  :
  # Options --xwin and --vcxsrv
  # --xwin for WSL and MSYS2
}
